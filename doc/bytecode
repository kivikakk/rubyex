RubyEx Bytecode Design
======================

    class Frank
      def initialize(name)
        puts "Hi #{name}."
      end

      def kill
        puts "I'm dead!"
      end
    end

    def do_it name
      f = Frank.new "Equinox"
      f.kill
      puts " -- #{name}"
    end

    do_it (rabid = "Forethought")

Now, we're tasked with converting this into bytecode. How do we handle the creation of classes, for instance? Or defining functions? We need to be aware of our "context", which is this strange `main` `Object`. MRI uses an internal variable, `ruby_class`/`ruby_cbase` (name changed) to keep track of this. It's important.

ruby-talk:207801 and :173746, both care of Guy Decoux, help us here.

At the top-level, `ruby_cbase` apears to be `Kernel`. `methods(false)` returns singleton methods. Note that the `main` object has very few singleton methods - any top-level defined functions do *not* go into `main`; they go into `Kernel`. `Kernel` is included in `Object`, and of course `main` is a sort of `Object`, and thus those methods are available here.

* `obj.instance_eval` renders: `self` = `obj`, `ruby_cbase` = `obj` singleton class - methods defined on instances of `obj`'s singleton class (`obj` itself)
* `obj.class_eval` renders: `self` = `obj`, `ruby_cbase` = `obj` - methods defined on instances of `obj`
* top level renders: `self` = `main`, `ruby_cbase` = `Object` [according to Guy Decoux -- but is it `Kernel`?] - methods defined on instances of `Object`
* `class A` renders: `self` = `ruby_cbase` = `A` - methods defined on instances of `A`
* `A#a` renders: `self` = `A` instance, `ruby_cbase` = `A` - methods defined on instances of `A`
* `A = Class.new` renders: `self` = `ruby_cbase` = `A` - methods defined on instances of `A`

